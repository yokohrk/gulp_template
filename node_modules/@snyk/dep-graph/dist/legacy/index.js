"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var crypto = require("crypto");
var builder_1 = require("../core/builder");
function depTreeToGraph(depTree, pkgManagerName) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var rootPkg, pkgManagerInfo, targetOS, builder, depGraph;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    rootPkg = {
                        name: depTree.name,
                        version: depTree.version,
                    };
                    pkgManagerInfo = {
                        name: pkgManagerName,
                    };
                    targetOS = depTree.targetOS;
                    if (targetOS) {
                        pkgManagerInfo.repositories = [
                            {
                                alias: targetOS.name + ":" + targetOS.version,
                            },
                        ];
                    }
                    builder = new builder_1.DepGraphBuilder(pkgManagerInfo, rootPkg);
                    return [4 /*yield*/, buildGraph(builder, depTree, depTree.name, true)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, builder.build()];
                case 2:
                    depGraph = _a.sent();
                    return [2 /*return*/, shortenNodeIds(depGraph)];
            }
        });
    });
}
exports.depTreeToGraph = depTreeToGraph;
function buildGraph(builder, depTree, pkgName, isRoot) {
    if (isRoot === void 0) { isRoot = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var getNodeId, depNodesIds, hash, deps, depNames, _i, depNames_1, depName, dep, subtreeHash, depPkg, depNodeId, treeHash, pkgNodeId, pkg, _a, depNodesIds_1, depNodeId;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    getNodeId = function (name, version, hashId) { return name + "@" + (version || '') + "|" + hashId; };
                    depNodesIds = [];
                    hash = crypto.createHash('sha1');
                    deps = depTree.dependencies || {};
                    depNames = _.keys(deps).sort();
                    _i = 0, depNames_1 = depNames;
                    _b.label = 1;
                case 1:
                    if (!(_i < depNames_1.length)) return [3 /*break*/, 4];
                    depName = depNames_1[_i];
                    dep = deps[depName];
                    return [4 /*yield*/, buildGraph(builder, dep, depName)];
                case 2:
                    subtreeHash = _b.sent();
                    depPkg = {
                        name: depName,
                        version: dep.version,
                    };
                    depNodeId = getNodeId(depPkg.name, depPkg.version, subtreeHash);
                    depNodesIds.push(depNodeId);
                    builder.addPkgNode(depPkg, depNodeId);
                    hash.update(depNodeId);
                    _b.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    treeHash = depNames.length ? hash.digest('hex') : 'leaf';
                    if (isRoot) {
                        pkgNodeId = builder.rootNodeId;
                    }
                    else {
                        pkg = {
                            name: pkgName,
                            version: depTree.version,
                        };
                        pkgNodeId = getNodeId(pkg.name, pkg.version, treeHash);
                        builder.addPkgNode(pkg, pkgNodeId);
                    }
                    for (_a = 0, depNodesIds_1 = depNodesIds; _a < depNodesIds_1.length; _a++) {
                        depNodeId = depNodesIds_1[_a];
                        builder.connectDep(pkgNodeId, depNodeId);
                    }
                    if (!(depNodesIds.length > 0)) return [3 /*break*/, 6];
                    return [4 /*yield*/, spinTheEventLoop()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [2 /*return*/, treeHash];
            }
        });
    });
}
function shortenNodeIds(depGraph) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var builder, nodesMap, _i, _a, pkg, nodeIds, i, nodeId, newNodeId, _b, _c, pkg, _d, _e, nodeId, _f, _g, depNodeId, parentNode, childNode;
        return tslib_1.__generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    builder = new builder_1.DepGraphBuilder(depGraph.pkgManager, depGraph.rootPkg);
                    nodesMap = {};
                    _i = 0, _a = depGraph.getPkgs();
                    _h.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 4];
                    pkg = _a[_i];
                    nodeIds = depGraph.getPkgNodeIds(pkg);
                    for (i = 0; i < nodeIds.length; i++) {
                        nodeId = nodeIds[i];
                        if (nodeId === depGraph.rootNodeId) {
                            continue;
                        }
                        newNodeId = void 0;
                        if (nodeIds.length === 1) {
                            newNodeId = "" + trimAfterLastSep(nodeId, '|');
                        }
                        else {
                            newNodeId = trimAfterLastSep(nodeId, '|') + "|" + (i + 1);
                        }
                        nodesMap[nodeId] = newNodeId;
                        builder.addPkgNode(pkg, newNodeId);
                    }
                    return [4 /*yield*/, spinTheEventLoop()];
                case 2:
                    _h.sent();
                    _h.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    _b = 0, _c = depGraph.getPkgs();
                    _h.label = 5;
                case 5:
                    if (!(_b < _c.length)) return [3 /*break*/, 8];
                    pkg = _c[_b];
                    for (_d = 0, _e = depGraph.getPkgNodeIds(pkg); _d < _e.length; _d++) {
                        nodeId = _e[_d];
                        for (_f = 0, _g = depGraph.getNodeDepsNodeIds(nodeId); _f < _g.length; _f++) {
                            depNodeId = _g[_f];
                            parentNode = nodesMap[nodeId] || nodeId;
                            childNode = nodesMap[depNodeId] || depNodeId;
                            builder.connectDep(parentNode, childNode);
                        }
                    }
                    return [4 /*yield*/, spinTheEventLoop()];
                case 6:
                    _h.sent();
                    _h.label = 7;
                case 7:
                    _b++;
                    return [3 /*break*/, 5];
                case 8: return [2 /*return*/, builder.build()];
            }
        });
    });
}
function spinTheEventLoop() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve) { return setImmediate(resolve); })];
        });
    });
}
function trimAfterLastSep(str, sep) {
    return str.slice(0, str.lastIndexOf(sep));
}
//# sourceMappingURL=index.js.map
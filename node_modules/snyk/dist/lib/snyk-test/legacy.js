"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
function convertTestDepGraphResultToLegacy(res, depGraph, packageManager, severityThreshold) {
    var result = res.result;
    var upgradePathsMap = new Map();
    for (var _i = 0, _a = _.values(result.affectedPkgs); _i < _a.length; _i++) {
        var pkgInfo = _a[_i];
        for (var _b = 0, _c = _.values(pkgInfo.issues); _b < _c.length; _b++) {
            var pkgIssue = _c[_b];
            if (pkgIssue.fixInfo && pkgIssue.fixInfo.upgradePaths) {
                for (var _d = 0, _e = pkgIssue.fixInfo.upgradePaths; _d < _e.length; _d++) {
                    var upgradePath = _e[_d];
                    var legacyFromPath = pkgPathToLegacyPath(upgradePath.path);
                    var vulnPathString = getVulnPathString(pkgIssue.issueId, legacyFromPath);
                    upgradePathsMap[vulnPathString] = toLegacyUpgradePath(upgradePath.path);
                }
            }
        }
    }
    // generate the legacy vulns array (vuln-data + metada per vulnerable path).
    //   use the upgradePathsMap to find available upgrade-paths
    var vulns = [];
    for (var _f = 0, _g = _.values(result.affectedPkgs); _f < _g.length; _f++) {
        var pkgInfo = _g[_f];
        for (var _h = 0, _j = depGraph.pkgPathsToRoot(pkgInfo.pkg); _h < _j.length; _h++) {
            var vulnPkgPath = _j[_h];
            var legacyFromPath = pkgPathToLegacyPath(vulnPkgPath.reverse());
            for (var _k = 0, _l = _.values(pkgInfo.issues); _k < _l.length; _k++) {
                var pkgIssue = _l[_k];
                var vulnPathString = getVulnPathString(pkgIssue.issueId, legacyFromPath);
                var upgradePath = upgradePathsMap[vulnPathString] || [];
                // TODO: we need the full issue-data for every path only for the --json output,
                //   consider picking only the required fields,
                //   and append the full data only for --json, to minimize chance of out-of-memory
                var annotatedIssue = Object.assign({}, result.issuesData[pkgIssue.issueId], {
                    from: legacyFromPath,
                    upgradePath: upgradePath,
                    isUpgradable: !!upgradePath[0] || !!upgradePath[1],
                    isPatchable: pkgIssue.fixInfo.isPatchable,
                    name: pkgInfo.pkg.name,
                    version: pkgInfo.pkg.version,
                    nearestFixedInVersion: pkgIssue.fixInfo.nearestFixedInVersion,
                });
                vulns.push(annotatedIssue);
            }
        }
    }
    var dockerRes = result.docker;
    if (dockerRes && dockerRes.binariesVulns) {
        var binariesVulns = dockerRes.binariesVulns;
        for (var _m = 0, _o = _.values(binariesVulns.affectedPkgs); _m < _o.length; _m++) {
            var pkgInfo = _o[_m];
            for (var _p = 0, _q = _.values(pkgInfo.issues); _p < _q.length; _p++) {
                var pkgIssue = _q[_p];
                var pkgAndVersion = pkgInfo.pkg.name + '@' + pkgInfo.pkg.version;
                var annotatedIssue = Object.assign({}, binariesVulns.issuesData[pkgIssue.issueId], {
                    from: ['Upstream', pkgAndVersion],
                    upgradePath: [],
                    isUpgradable: false,
                    isPatchable: false,
                    name: pkgInfo.pkg.name,
                    version: pkgInfo.pkg.version,
                    nearestFixedInVersion: pkgIssue.fixInfo.nearestFixedInVersion,
                });
                vulns.push(annotatedIssue);
            }
        }
    }
    var meta = res.meta || {};
    severityThreshold = (severityThreshold === 'low') ? undefined : severityThreshold;
    var legacyRes = {
        vulnerabilities: vulns,
        ok: vulns.length === 0,
        dependencyCount: depGraph.getPkgs().length - 1,
        org: meta.org,
        policy: meta.policy,
        isPrivate: !meta.isPublic,
        licensesPolicy: meta.licensesPolicy || null,
        packageManager: packageManager,
        ignoreSettings: meta.ignoreSettings || null,
        docker: result.docker,
        summary: getSummary(vulns, severityThreshold),
        severityThreshold: severityThreshold,
    };
    return legacyRes;
}
exports.convertTestDepGraphResultToLegacy = convertTestDepGraphResultToLegacy;
function getVulnPathString(issueId, vulnPath) {
    return issueId + '|' + JSON.stringify(vulnPath);
}
function pkgPathToLegacyPath(pkgPath) {
    return pkgPath.map(toLegacyPkgId);
}
function toLegacyUpgradePath(upgradePath) {
    return upgradePath
        .filter(function (item) { return !item.isDropped; })
        .map(function (item) {
        if (!item.newVersion) {
            return false;
        }
        return item.name + "@" + item.newVersion;
    });
}
function toLegacyPkgId(pkg) {
    return pkg.name + "@" + (pkg.version || '*');
}
function getSummary(vulns, severityThreshold) {
    var count = vulns.length;
    var countText = '' + count;
    var severityFilters = [];
    var SEVERITIES = ['low', 'medium', 'high'];
    if (severityThreshold) {
        SEVERITIES.slice(SEVERITIES.indexOf(severityThreshold)).forEach(function (sev) {
            severityFilters.push(sev);
        });
    }
    if (!count) {
        if (severityFilters.length) {
            return "No " + severityFilters.join(' or ') + " severity vulnerabilities";
        }
        return 'No known vulnerabilities';
    }
    if (severityFilters.length) {
        countText += ' ' + severityFilters.join(' or ') + ' severity';
    }
    return countText + " vulnerable dependency " + pl('path', count);
}
function pl(word, count) {
    var ext = {
        y: 'ies',
        default: 's',
    };
    var last = word.split('').pop();
    if (count > 1) {
        return word.slice(0, -1) + (ext[last] || last + ext.default);
    }
    return word;
}
//# sourceMappingURL=legacy.js.map